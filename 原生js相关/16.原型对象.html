<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
    <input type="text" id="input" oninput="textCount()">
    <span id="span"></span>
    <button id="btn">测试</button>
    <hr>
    从 ECMAScript 6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器
    <br>来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。

    <h3>重点: Object(对象)都有__proto__这个属性,指向某一个原型对象  </h3>
     
    <div class="content">
      前置知识     __proto__:隐式原型  prototype:显式原型
      (以下对象属性,保存的是指针)
       <p> 1.每个构造函数都有一个显式原型</p>
       <p> 2.每个对象都有__proto__隐式原型 属性</p>
       <p> 3.实例对象是由构造函数 new 出来的  new Function创造函数    new Object 创造对象</p>
       <p> 4.原型对象 身上都有.constructor ,__proto__ 两个属性</p>
       <p> 5.__proto__指向 构造函数的  实例对象</p>
       <p> 6. Object.prototype.__proto__ 指向null  原型链的终点</p>

     
    </div>
    <h4>当我使用实例对象Tian(我自己定义的)的方法/数据,实例本身没有时候,会往他的原型对象查找(__proto__指向)</h4>
     <div class="content">
      <p >1.__proto__指向了原型对象</p>
      <p >2. 实例对象的  [构造函数(构造者/一些抽象的属性,方法) ]的 原型对象</p>
     </div>
     <h3>原型链例子</h3>
        <div class="content">
一.第四个链稍微有点绕,所有函数 都由new Function() 产生 所以函数的隐式原型为Function 原型对象
二.     而Function(){} 构造函数又由 Function构造函数生成
三.       Object(){}  构造函数 也由 Function构造函数生成
四.      所以Object和Function  两个构造函数 的隐式原型 都指向了 Function 原型对象 <hr>

            1. obj = new Object()       
            f  =  new Function() 
            <br>  
            obj为对象   实例对象     f 为函数  实例对象
            Object()为对象的构造函数 \ Function() 为函数的构造函数 
            2.实例对象的隐式原型 指向其构造函数的 显式原型
            
            一.构造函数Function(){} == __proto__ >> Function原型对象 ==__proto__>> 构造函数Object.prototype ==__proto__>> null
            <hr>

           二.f函数实例  ==__proto__>> Function原型对象  ==__proto__>> 构造函数Object.prototype ==__proto__>> null
            <hr>
            三.obj对象实例   == __proto__>> 构造函数Object.prototype ==__proto__>> null 
            <hr>
            四. 构造函数Object(){}.__proto__  ==>  Function原型对象   
        </div>

        
        <p id="show"></p>
        <textarea class="text"></textarea>
       

     <div  class="explain">
        <div> 
          1. 什么是原型：
          任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属
         性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个
         构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有
         prototype。
      
        </div>
        <div>  2.什么是原型链？
          原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
          我们知道，每个构造函数都有一个原型对象，每个原型对象都有一个指向构造函
          数的指针，而实例又包涵一个指向原型对象的内部指针。<br>&nbsp;&nbsp;&nbsp;

         <p> 原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就
            一层层的扒出创建对象的构造函数，直至到 Object 时，就没有_proto_指向了。
            因为_proto_实质找的是 prototype，所以我们只要找这个链条上的构造函数的
            prototype。其中 Object.prototype 是没有_proto_属性的，它==null。
           每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而
          实例都包含指向原型对象内部的指针。我们让原型对象（1）等于另一个原型对
           象的实例（2）,此时原型对象（2）将包含一个指向原型对象（1）的指针，
           再让原型对象（2）的实例等于原型对象（3），如此层层递进就构成了实例和原
           型的链条，这就是原型链的概念.</p>  
          <p> 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针
            (constructor)，而实例对象都包含一个指向原型对象的内部指针(__proto__)。
            如果让原型对象等于另一个原型对象的实例，此时的原型对象将包含一个指向另
            一个原型的指针(__proto__)，另一个原型也包含着一个指向另一个构造函数的
            指针(constructor)。假如另一个原型又是另一个类型的实例……这就构成了实
            例与原型的链条。也叫原型链.</p>
       
         
      </div>
        <div>3.原型继承是 js 的一种继承方式，原型链作为实现继承的主要方法,其基本思路是
          利用原型让一个引用类型继承另一个引用类型的属性和方法, 
          原型继承：利用原型中的成员可以被和其相关的对象共享这一特性，可以实现继
          承，这种实现继承的方式，就叫做原型继承
        </div>
     </div>
</body>

<style>
  *{
    margin:0;
    padding: 0;


  }

  #input{
    width: 200px;
    background-color: lightblue;
  }

  #btn {
    width: 50px;
  }
 .text {
  width: 500px;
  height: 200px;
  font-size: 20px;
  font-weight: 700;
 }
  .content {
    background-color: lightgoldenrodyellow;
  }

  .explain {
    width: 800px;
    margin: 0 auto ;
    background-color: lightgreen;
    font: 20px  Georgia, 'Times New Roman', Times, serif;
    font-weight: 700;
    text-indent: 2em;
  }
</style>

<script>
      let input = document.querySelector("#input");
      let span = document.querySelector("#span");
      let btn = document.querySelector("#btn");
      let text = document.querySelector('.text')
      let showSpan = document.querySelector('#show')

      text.onkeydown = textShow
     
      btn.onclick =  textCount
      
      function textCount(){

        count = localStorage.getItem('count')
        if(count){
          count ++ 
          localStorage.setItem('count',count)
        }else{
          let count = 0
          localStorage.setItem('count',count)
        }

        
        span.innerHTML = localStorage.getItem('count')
      }

      function Person(name,age,gender) {
        this.name = name;
        this.age = age;
        this.gender =gender
      }

     function textShow(e){
        if(e.keyCode === 13){
          showSpan.innerText = text.value
        }
       

     }  

      let tian =new Person('tian',28,3)

      console.log(Object,"Object");
      console.log(Person,'构造函数');
      console.log( tian,'实例对象');
      console.log( tian.__proto__,'实例对象的__proto__ 指向了构造函数的原型(prototype)对象');
      
      console.log('--------');

      Person.prototype.a = 1;
      
      console.log(Person.prototype,'构造函数  的 原型');  
      console.log('--------');
      console.log(tian.prototype,'实例对象.prototype 的 原型');//null  
      console.log(Object.getPrototypeOf(tian) ,'Object.getPrototypeOf() 实例对象的  原型指向');//null  
      console.log('--------');
      console.log(Object.prototype ,'object原型');




      

      

      

</script>
</html>